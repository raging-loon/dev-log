<!DOCTYPE html>
<html>
    <head>
        <title>Constant Expressions: A Method of Hiding Malicious Data at Compile Time</title>
        <link rel="stylesheet" href="../../../../css/styles.css">
        <link rel="stylesheet" href="../../../../js/highlight/styles/github-dark.min.css">
        <script src="../../../../js/highlight/highlight.min.js"></script>
        <script src="../../../../js/highlight/languages/cpp.min.js"></script>
    </head>
    <body class="article-page">
        <script>hljs.highlightAll();</script>
        <center><h1 class="article-title">Constant Expressions: A Method of Hiding Malicious Data at Compile Time</h1></center>
        <hr>
        <div class="article-body">
            <section id="toc">
                <h2 class="article-title">Table of Contents</h2>
                <ol>
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#constant-expressions">Constant Expressions and Type Deduction</a></li>
                    <li><a href="#xor-enc">XOR Encryption</a></li>
                    <li><a href="#rolling-xor">Rolling XOR Encryption</a></li>
                    <li><a href="#keygen">Key Generation</a></li>
                    <li><a href="#poly">Polymorphic Encryption</a></li>
                    <li><a href="#speck">Speck 64/128 Encryption</a></li>
                    <li><a href="#closing-thoughts">Closing Thoughts</a></li>
                </ol>
            </section>
            <section id="introduction">
                <h2>Introduction</h2>
                <p>When you are analyzing a piece of malware, or even just benign software in general, the first thing you might look at are strings. Strings could reveal data such as IP Addresses, domain names, error messages, and even things like WMI Queries or embedded scripts. I've seen some malware brazenly brand itself as such using the strings within it.</p>
                <p>As a malware developer, you must take care to NOT reveal your presence. One way could be to encrypt the data used by your program. It is easy to grep a domain name or IP addresses. It is much harder to grep for binary data, especially when you have no idea what it might look like.</p>
                <p>This could be done by manually encrypting the data and copying or linking it to your code. You might even use an automated obfuscation. But what if there was a way to just write the domain name and have the compiler encrypt it for you? This article aims to introduce methods that can perform encryption at compile time. I will be using C++20 for this, but all of what I am covering it transferable to other compiled languages such as Rust, D, and to an extent, C.</p>
            </section>
            <section id="constant-expressions">
                <h2>Constant Expressions</h2>
                <p>
                    According to the C++ documentation, a constant expression "defines an expression that can be evaluated at compile time." This is similar to macros in C, the difference being that actual computation is occurring, not just copy-and-paste. In C++, constant expressions are defined by using the <code>constexpr</code> or <code>consteval</code> specifiers.
                </p>
                <h3>constexpr</h4>
                <p>
                    This specifier was introduced in C++11 and specifies that an expression can <b>optionally</b> be evaluated at compile time. In modern C++, it seems that it is most commonly used as a type-safe replacement for C-Style Macros:
                </p>
                <pre><code class="language-cpp">
#define PI 3.14149
// changes to
constexpr float PI = 3.14159;
                </code></pre>
                <p>They can also be used to evaluate functions:</p>
                <pre><code class="language-cpp">
constexpr int GCD(int x, int y) 
{
    return (y == 0) ? x : GCD(y, x % y);
}                    
                </code></pre>
                <p>It is important to note that just because something is marked as <code>constexpr</code>, that does not mean that it <i>will</i> be evaluated at compile time. The compiler can choose not to.</p>
                <h3>consteval</h3>
                <p>However, anything marked as <code>consteval</code> <b>must</b> be evaluable at compile time, you will receive an error otherwise.</p>
                <pre><code class="language-cpp">
consteval int GCD(int x, int y)
{
    return (y == 0) ? x : GCD(y, x % y);
}

constexpr int yval = 10;
constexpr compileTime = GCD(23, yval);

int xval = 23;
int compilerError = GDC(xval, 10);            
                </code></pre>
                <p>
                You can think of <code>constexpr</code> as a request to the compiler to evaluate your expression at compile time. You can think of <code>consteval</code> as a contract between you and the compiler that your expression must be evaluable at compile time.
                </p>
                <h2>Non-Type Template Paramters and Type (and Non-Type) Deduction</h2>
                <p>When using templates in C++, you do not necessarily need to use type-ed parameters. Instead, you could literals such as integers or even <code>constexpr</code> variables. This could, for example, be used for sizing as in <code>std::array</code> or in our case, loop and recursive functions:</p>
                <pre><code language="language-cpp">
/// Recursive Constant Expression
template < std::size_t N >
consteval bool contains_b(const char (&str)[N]) 
{
    if constexpr (N == 1)
        return false;
    if(str[N - 2] == 'b')
        return true;
    
    return contains_b<N - 1>(str);
}

/// Iterative Constant Expression
template < std::size_t N >
consteval bool contains_b(const char (&str)[N])
{
    for(std::size_t i = 0; i < N; i++)
    {
        if(str[i] == 'b')
            return true;
    }
    return false;
}
                </code></pre>
                <p>I will be using iteration through all of the examples here. Recursion seems to be used extensively in more complicated template systems like type-lists.</p>
                <p>When using those above functions, we do not necessarily need to explicitly pass a parameter for N. Instead, we can have the compiler deduce it for us:</p>
                <pre><code class="language-cpp">
constexpr bool b = contains_b("Homber Simbson");
// is equivalent to
constexpr bool b = contains_b<>("Homber Simbson");
// and 
constexpr bool b = contains_b<16>("Homber Simbson");                 
                </code></pre>
                <p>This can make development easier as we</p>
                <ol><li>can write much less code</li><li>do not have to manually change sizes/types when code inevitably changes</li></il></ol>
            </section>
            <section id="xor-enc">
                <h2>XOR Encryption</h2>
                <p>This example, and most (if not all) subsequent examples, will use an STL container called <code>std::array</code>. This is a constant expression compatible contains that similar to a C-style array. It takes a type and a size (non-type) as its template parameters.</p>
                <pre><code class="language-cpp">
constexpr uint32_t XOR_KEY = 131;
// auto is used here so we don't need to write out "std::array<char, N>"
// This is another form of type deduction
template < std::size_t N >
consteval auto XOR_ENC_STR(const char (&str)[N]) 
{
    std::array< char, N > output = {}; // default initialize
    for(std::size_t i = 0; i < N - 1; i++)
        output[i] = str[i] ^ XOR_KEY;
    // optionally, we could add a NULL byte
    return output;
}
                </code></pre>
                <p>We can use it to hide data like this:</p>
                <pre><code class="language-cpp">
constexpr auto KL_ICMP_LIB_NAME             = CT_XOR_ENC_STRING("IPHLPAPI.DLL");
constexpr auto KL_ICMP_CREATE_FILE_NAME     = CT_XOR_ENC_STRING("IcmpCreateFile");
constexpr auto KL_ICMP_SEND_ECHO_NAME       = CT_XOR_ENC_STRING("IcmpSendEcho");
constexpr auto KL_ICMP_CLOSE_HANDLE_NAME    = CT_XOR_ENC_STRING("IcmpCloseHandle");                    
                </code></pre>
                <p>and let the compiler deduce types and non-types for us.</p>
            </section>
            <section id="rolling-xor">
                <h2>Rolling XOR Encryption</h2>
                <p>You will see no reference to the above strings in the final executable, lest they are referenced elsewhere, unencrypted. However, it is a bit obvious that <i>something</i> is there:</p>
                <img src="media/rollingxor1.png" class="article-image">
               <p><code>ca e0 ee f3</code> is "Icmp" encrypted with the XOR key of 131.</p> 
               <p>One solution could be a rolling set of keys. These could be hardcoded: an array of keys that we iterate through and roll over at the end.</p>
               <pre><code class="language-cpp">
constexpr std::array< uint8_t, 64 > XOR_KEYS = { /* 64 8-bit integers */ };
constexpr std::size_t NUM_XOR_KEYS = XOR_KEYS.size();

template < std::size_t N >
consteval auto ROLLING_XOR_HARDCODED(const char (&str)[N], std::size_t keyIndex = N) 
{
    std::array< char, N > output = {};
    
    uint8_t key = XOR_KEYS[keyIndex];
    
    for(std::size_t i = 0; i < N; i++)
    {
        output[i] = str[i] ^ XOR_KEYS[keyIndex];
        // increment or roll over
        keyInedx = (keyIndex + 1) % NUM_XOR_KEYS;
    }

    return output;
}
               </code></pre>
               <p>This function uses an array of 64 8-bit integers. It will roll through and possibly back over them to encrypt the string. The starting position in the key array is determined by the length of the string. This could however be “influenced” by adding some null bytes or setting the <code>keyIndex</code> argument manually. It could even be computed algorithmically.</p>
                <img src="media/rollingxor2.png" class="article-image"><br>
                <img src="media/rollingxor3.png" class="article-image">
                <br>
                <p>The only disadvantage is that the decryption keys are stored out in the open. This could be solved by encrypting them as well, or perhaps through key generation.</p>
            </section>
            <section id="keygen">  
                <h2>Key Generation Algorithms</h2>
                <p>These solution require a bit more code, but will note leave a trace of our keys almost anywhere. Here I will demonstrate the <a href="https://medium.com/r/?url=https://en.wikipedia.org/wiki/Linear_congruential_generator">Linear Congruential Generation</a> and <a href="https://en.wikipedia.org/wiki/Middle-square_method">Middle Square algorithms.</a></p>
                <h3>Linear Congruential Generation</h3>
                <p>The LCG algorithm takes four parameters. Mathematically, it takes a sequence and outputs a sequence.</p>
                <img src="media/lcg.png" class="article-image"> 
                <p><i>a</i> is the <i>multiplier</i>. <i>c</i> is the <i>increment</i>. <i>m</i> is the <i>modulus</i>. <i>m</i> defines a range and ensure the output will fall within it.</p>
                <p>Here is the constant expression for it:</p>
                <pre><code class="language-cpp">
constexpr uint8_t LCG(uint8_t seed)
{
    // 255 is used to make sure we stay within the 
    // 8-bit boundary
    constexpr uint8_t a = 75, c = 76, m = 255;
    return (a * seed + c) % m;
}                    
                </code></pre>
                <p>And here are the results when the length of the string is used as a seed:</p>
                <img src="media/xor1_lcg.png" class="article-image"> 
                <h3>Middle Square</h3>
                <p>This algorithm will square the seed, then extract the middle bits.</p>
                <img src="media/middle_square_diagram.png" class="article-image"> 
                <p>The function is almost exactly like it's mathematical representation:</p>
                <pre><code class="language-cpp">
constexpr uint8_t MIDDLE_SQUARE(uint8_t seed)
{
    return ((seed * seed) >> 4) & 0xFF;
}                    
                </code></pre> 
            </section>
            <section id="poly">
                <h2>Polymorphic Encryption</h2>
                <p>While the middle square algorithm is exceedingly simple, it tends to be unsuitable for larger inputs (i.e. long strings in our case). One way this could be resolved is by dynamically determining which algorithm to use based on the length of the string.</p>
                <p>A powerful feature of constant expressions in C++ is the "constexpr if". This can let us make decisions during compile time, even outside of a <code>constexpr</code> function. For example, say I have two memory allocators. One is best suited for tiny, minuscule objects (perhaps the allocator Alexandrescu showcased in <i>Chapter 4 of Modern C++ Design</i>). The other might work well with large objects (perhaps a handle system?). Instead of making the decision manually for each object, since sizes can change throughout development, we can create an interface and rely on the compiler to do the heavy lifting:</p>
                <pre><code class="language-cpp">
void* alloc(size_t size)
{
    if constexpr(size <= MAX_SMALL_OBJ_SIZE)
        return SmallObjAllocator::allocate(size);
    else
        return LargeObjAllocator::allocate(size);
}
                </code></pre>
                <p>We can do the same thing using our key generation algorithms, <i>so long as the same is done during decryption.</i></p>
                <pre><code class="language-cpp">
template < std::size_t N >
consteval auto POLY_XOR_ENCRYPT(const char (&str)[N])
{
    std::array< char, N > output = {};
    uint8_t key;

    if constexpr(n >= MID_SQR_MAX)
        key = LCG(N);
    else
        key = MIDDLE_SQUARE(N);
    ...
    encryption stuff
    ...
    return output;
}
                </code></pre>
                <p>In this image, the first value uses middle square, while the second uses LCG.</p>
                
                <img src="media/poly.png" class="article-image"> 
            </section>
            <section id="speck">
                <h2>Speck 64/128 Encryption</h2>
                <p>Throughout this article, I have exclusively covered XOR encryption. After much research, I found an algorithm that could be feasibly implemented using constant expressions.</p>
                <p>Speck encryption is a block cipher released by the NSA. It uses something called a key schedule. Key Scheduling will generate a series of derived keys which will be used during the encryption and decryption process. This is similar to a mathematical pipeline. You generate this pipeline by performing a series of operations on your key, then use the pipeline during encryption/decryption.</p>
                <p>Here is the full implementation guide provided by the NSA. I have copied most of the code for Speck64_128, modifying it such that it worked well with C++20 and constant expressions.</p>
                <p>Here are the steps taken for Speck encryption:</p>
                <ol>
                    <li>Split the input into 64-bit blocks, padding with zeroes</li>
                    <li>Generate a key schedule from the 128-bit key</li>
                    <li>Run the encryption algorithm omn the blocks from step 1 using the key schedule from step 2</li>
                </ol>
                <p>The entire implementation is about 150 lines of code. I will not be copying it into this article, but you can find it <a href="https://github.com/raging-loon/ConstantExpressions/blob/main/Speck64_128.h">here</a>. I will however provide the interface:</p>
                <pre><code class="language-cpp">
template < std::size_t N >
constexpr auto Speck64EncryptString(const char (&str)[N]), const KeyArray& key)
{
    constexpr int numBlocks = (N + 4) / 8;
    std::array< uint64_t, numBlocks > output = {};
    
    auto blocks = Speck64GenerateBlocks(str);
    RoundKeyArray rka = Speck64128KeySchedule(key);
    
    for(std::size_t i = 0; k < blocks.size(); i++)
    {
        if(blocks[i] == 0)
            break;
        output[i] = Speck64128EncryptBlock(blocks[i], rka);
    }

    return output;
}
                </code></pre>
                <p>Encrypting might look like this:</p>
                <pre><code class="language-cpp">
constexpr KeyArray KA = { /* 4 32-bit integers */ }
constexpr auto ICMP_LIB_NAME = Speck64EncryptString("IPHLPAPI.DLL", KA);                 
                </code></pre>
                <p>And voila: an incoherent sequence of numbers</p>
                <img src="media/speck.png" class="article-image"> 
                <p>Please note that your cipher blocks will be backwards. To reconstruct, you will have to start at the first bit and make your way to the last.</p>
            </section>
            <section id="artificial-xor">
                <h2>Extra: Artificial XOR</h2>
                <p>Here is a look at the disassembly for one of the XOR encryption algorithms that was compiled for runtime use:</p>
                <img src="media/ida1.png" class="article-image"> 
                <p>A smart static analyzer could classify this as XOR encryption/decryption. In this loop there are 4 operations: data retrieval, data storage (function calls), XOR, and the rolling key adjustment. Key adjustment accounts for the last several lines.</p>
                <p>One thing we could do is create an artificial XOR algorithm using its base components. Formally, XOR is a combination of NOT, AND, and OR:</p>
                <img src="media/xor.png" class="article-image"> 
                <p>This can be replicated using a tiny function:</p>
                <pre><code class="language-cpp">
template < typename T >
constexpr inline T FAKE_XOR(T a, T b)
{
    return (a & ~b) | (~a & b);
}                  
                </code></pre>
                <p>Then we can integrate it into our constant expressions as deemed fit:</p>
                <img src="media/ida2.png" class="article-image"> 
                <p>Now our function is larger and it is less clear what it is doing. The extra calls to the '[]' operator are due to optimization being turned off. Somewhat ironically, the XOR at the end is a compiler optimization. <code>xor edx, edx</code> is faster that <code>mov edx, 0</code>.</p>
            </section>
            <section id="closing-thoughts">
                <h2>Closing Thoughts</h2>
                <p>A lot of the functions demonstrated in this article can be layered. For example, you could use the key generation algorithms to generate starting indices for the rolling encryption algorithm. You could also encrypt the Speck 64/128 encryption key.</p>
                <p><i>What else can you do with constant expressions?</i></p>
                <ul>
                    <li>Encoding such as base64, or perhaps even URL encoding</li>
                    <li>Encrypting Structures. You could create an interface that provides encryption services in the general sense, allowing you to encrypt structs or classes. You could model this interface based on STL patterns like <code>std::hash</code></li>
                    <li>Embedded encryption: you could embed and encrypt things like images, executables, scripts, and so on.</li>
                </ul>
                <p><i>But why would I use constant expressions?</i></p>
                <ul>
                    <li>It hides the data before the executable is even created. There is zero trace of the original data in the binary at all.</li>
                    <li>It is more powerful and flexible than copy-and-paste</li>
                    <li>It makes development easier. You can encrypt and decrypt a string painlessly. Type deduction only makes it easier.</li>
                </ul>
                <p><i>Does this work on other platforms?</i></p>
                <p>Yes, so long as you use a C++20 compatible compiler.</p>
                <p><i>Are there legitimate uses for constant expressions?</i></p>
                <p>Absolutely. You can use them to define constants in a more type-safe way. You will likely find yourself using them if you are doing any type of fancy template metaprogramming. You could also use them for quick data transformation, such as seconds to milliseconds. For example, user-defined literals are often constant expressions. Take a look at <code>std::literals::chrono_literals</code> for some real world examples.</p>
                <p>You can find all of the code for this article right <a href="https://github.com/raging-loon/ConstantExpressions/">here</a>.</p>
            </section>
        </div>
    </body>
</html>