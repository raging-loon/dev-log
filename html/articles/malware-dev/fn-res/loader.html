<!DOCTYPE html>
<html>
    <head>
        <title>Manual Loading Functions and Libraries for EDR/AV Bypass</title>
        <link rel="stylesheet" href="../../../../css/bootstrap.min.css">
        <link rel="stylesheet" href="../../../../css/styles.css">
        <link rel="stylesheet" href="../../../../js/highlight/styles/github-dark.min.css">
        <script src="../../../../js/highlight/highlight.min.js"></script>
        <script src="../../../../js/highlight/languages/cpp.min.js"></script>
        <script src="../../../../js/highlight/languages/x86asm.min.js"></script>
        <script src="../../../../js/bootstrap.min.js"></script>
    </head>
    <body class="article-page">
        <script>hljs.highlightAll();</script>
        <div class="container-fluid p-5 bg-black text-white text-center">
            <h1>Manual Loading Functions and Libraries for EDR/AV Bypass</h1>
        </div>
        <div class="container-fluid bg-dark">
                <br>
        <div class="container-fluid article-body bg-dark text-white">
            <section id="toc">
                <h2 class="article-title">Table of Contents</h2>
                <ol>
                    <li><a href="#introduction">Using WINAPI's LoadLibary and GetProcAddress</a></li>
                    <li><a href="#peb">Loading Libraries directly from the PEB</a></li>
                    <li><a href="#peb-access">Disguising access to the PEB using assembly</a></li>
                    <li><a href="#load-export">Loading Functions from an executable's Export Table</a></li>
                    <li><a href="#bonus">Bonus: Function Address Obfuscation</a></li>
                </ol>
            </section>
            <section id="introduction">
                <h2>Using WINAPI's LoadLibrary and GetProcAddress</h2>
                <p>One of the <i>very first things</i> an analyst will do is get an overall picture of what a malware sample is doing. This will likely include listing all function imports and exports. You can hide what functions you import by not using them directly i.e. not allowing MSVC or whatever other compiler you are using to resolve function references for you. Windows provides a handful of functions for doing just this: <code>LoadLibrary(Ex)</code>, <code>GetProcAddress</code>, <code>GetModuleHandle</code>, and so on. I will focus on the former two.</p>
                <p>Some malware will use these two functions without any form of obfuscation. For example, Ursnif loads <code>VirtualAlloc</code> and <code>CreateThread</code> very blatantly:</p>
                <pre><code lang="language-cpp">
// Note this is not a 1-1 copy of Ursnif
HMODULE hMod = LoadLibrary("KERNEL32.dll");

if(hMod == INVALID_HANDLE_VALUE)
    ... error handling ...

myVirtualAlloc = (MyVirtualAlloc_t*)GetProcAddress(hMod, "VirtualAlloc");
                </code></pre>
                <p>This is great and very easy to use, but it is also highly detectable. For starters, you now have references to the strings "KERNEL32.DLL" and "VirtualAlloc" in your executable. This could be easily encrypted, perhaps by <a href="https://raging-loon.github.io/dev-log/html/articles/malware-dev/constant-expressions/constant-expressions.html">using constant expressions</a>. Secondly, some EDR solutions can hook onto or inject code into various DLLs to validate it's parameters. Sophos Intercept X does this. You can read about bypassing that <a href="https://www.malwaretech.com/2023/12/silly-edr-bypasses-and-where-to-find-them.html">here</a>. This means that, even if you do encrypt your function/library names, a well-built EDR could still detect that which you are loading. In some cases, this is irrelevant. In others, it is inevitable, especially if you are loading non-system-related libraries e.g. for COM. One way to bypass this could be to load system-related libraries directly from the Process Environment Block (PEB).</p>
            </section>
            <section id="peb">
                <h2>Loading Libraries Directly from the Process Environment Block</h2>
                <p>The PEB is a usermode data structure that is not really meant for us peon software devs to use. It contains some information about debugging and loaded modules, however, which are extremely useful. It is considered an "opaque" data structure as its public implementation is heavily obfuscated. Here is the "official" version listed in the <code>wintrnl.h</code> header provided by Microsoft:</p>
                <pre><code lang="language-cpp">

typedef struct _PEB {
    BYTE Reserved1[2];
    BYTE BeingDebugged;
    BYTE Reserved2[1];
    PVOID Reserved3[2];
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID Reserved4[3];
    PVOID AtlThunkSListPtr;
    PVOID Reserved5;
    ULONG Reserved6;
    PVOID Reserved7;
    ULONG Reserved8;
    ULONG AtlThunkSListPtr32;
    PVOID Reserved9[45];
    BYTE Reserved10[96];
    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
    BYTE Reserved11[128];
    PVOID Reserved12[1];
    ULONG SessionId;
} PEB, *PPEB;
                </code></pre>
                <p>Everything marked as reserved is meant for internal use by the kernel. Here is a table containing the PEBs internal fields (Windows Internals, Part 1, 7e):</p>
                <img src="media/peb.png" class="article-image img-fluid">
                <p>However, you can find an outdated but relevant header file from the Windows Server 2003 source code leak <a href="https://github.com/tongzx/nt5src/blob/master/Source/XPSP1/NT/public/sdk/inc/pebteb.h">here</a>.</p>
                <p>The field we are most concerned with is <code>Ldr</code>. It contains contains a circularly linked list of <code>LDR_DATA_TABLE_ENTRY</code> which contains the name of a single module. Here is it's definition: </p>
                <pre><code lang="language-cpp">
typedef struct __LDR_DATA_TABLE_ENTRY 
{
    LIST_ENTRY  InLoadOrderLinks;
    LIST_ENTRY  InMemoryOrderLinks;
    LIST_ENTRY  InInitializationOrderLinks;
    PVOID       DllBase;
    PVOID       EntryPoint;
    ULONG       SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;

} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
                </code></pre>
               
                <h3>Accessing the PEB</h3>
                <p>Segment registers are not commonly used in the x64 architecture. They were every prevalent in x86, however. On x64 processes, the PEB is located at offset 0x60 from the GS register: <code>gs:[0x60]</code>. On x86 processors it can be found at offset 0x30 from the FS register: <code>fs:[0x30]</code>.</p>
                <h3>Parsing the <code>PEB_LDR_DATA</code> Structure for Modules</h3>
                <p>This diagram illustrates how this will be done:</p>
                <img src="media/modlist.png" class="article-image img-fluid">
                <p>And here is example code demonstrating it. Note that, if it fails to find the library in the PEB, it resorts to <code>LoadLibrary</code>.</p>
                <pre><code lang="language-cpp">
HMODULE LoadModule(LPCSTR name) 
{
    WCHAR wide[MAX_PATH];
    memset(wide, 0, sizeof(wide));

    size_t cnv = 0; // needed for conversion function
    size_t len = strlen(name) + 1;

    // convert to a wide character string
    mbstowcs_s(&size, wide, name, len);

    PPEB peb = (PPEB)__readgsqword(0x60);

    PPEB_LDR_DATA ldr = peb->Ldr;

    LIST_ENTRY* head = &ldr->InMemoryOrderModuleList;
    LIST_ENTRY* current = head->Flink;

    while(current != head) 
    {
        PLDR_DATA_TABLE_ENTRY entry = CONTAINING_RECORD(current, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if(entry && _wcsicmp(entry->BaseDllName.Buffer, wide) == 0)
            return (HMODULE)entry->DllBase;
        current = current->Flink;
    }
    // failover
    return LoadLibrary(name);
}
                </code></pre>
            </section>
            <section id="peb-access">
                <h2>Disguising access to the PEB using assembly</h2>
                <p>Most disassemblers can associate access to the GS register with the PEB:</p>
                <pre><code lang="x86asm">
mov rax, gs:[0x60]
                </code></pre>
                <p>This very obviously corresponds to PEB access on Windows systems. Smart disassemblers like Ghidra can pick up on this.</p>
                <p>Instead of using <code>__readgsqword</code> directly, you could write a general wrapper around it using a few lines of assembly: </p>
                <pre><code lang="x86asm">
ReadGSQword PROC
    mov rax, gs:[rcx]
    ret
ReadGSQword ENDP
                </code></pre>
                <p><code>RCX</code> stores the first (and only) parameter of this function in accordance to the x64 calling convention. <code>RAX</code> stores the return value. To use it, we call it like any other C function:</p>
                <pre><code lang="language-cpp">
extern uint64_t ReadGSQword(uint64_t offset);

PPEB peb = (PPEB)ReadGSQword(0x60);
                </code></pre>
                <p>Note that the process of compiling and linking an assembly file will vary on your compiler and architecture. 64-bit MSVC++ will require you to use a separate assembly file as it forbids inline assembly.</p>
                
            </section>
            <section id="load-export">
                <h2>Loading Functions from the Data Export Table</h2>
                <p>In memory, executables looks the exact same as they do on the disk. If they do not, you could be dealing with polymorphic malware or (*cringes*) <a href="https://www.crowdstrike.com/en-us/blog/herpaderping-security-risk-or-unintended-behavior/">herpaderping</a>.</p>
                <p>That being said, once you obtain a handle to a library, e.g. via <code>GetModuleHandle</code>, you can parse it as if it were a file. This image demonstrates how the export table can be found based on the various headers in a PE file.</p> 
                <p> Note that the numbers correspond to comments in the code that will be presented shortly. </p>
                <img src="media/export2.png" class="article-image img-fluid">
                <br>
                <p>Finding this is very straightforward. It requires a little bit of pointer arithmetic, but these things often do.</p>
                <pre><code lang="language-cpp">
void* GetFunctionAddress(HMODULE hModule, LPCSTR name)
{
    if(!hModule || !name)
        return nullptr;

    // 1.
    IMAGE_DOS_HEADER* dosHeader = (IMAGE_DOS_HEADER*)hModule;
    
    // 2.
    IMAGE_NT_HEADERS* ntHeaders = (IMAGE_NT_HEADERS*)((UINT8*)hModule + dosHeader->e_lfanew);

    //                                3. ~~~~~~~~~~~~~~~~~~v            4. ~~~~~~~~~~~~~~~~~~~~v
    IMAGE_DATA_DIRECTORY exportLocation = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
    // 5.
    IMAGE_EXPORT_DIRECTORY* exports = (IMAGE_EXPORT_DIRECTORY*)((UINT8*)hModule + exportLocation.VirtualAddress);

    void* function = nullptr;

    // 6.
    DWORD* functionList = (DWORD*)((UINT8*)hModule + exports->AddressOfFunctions);
    DWORD* nameList     = (DWORD*)((UINT8*)hModule + exports->AddressOfNames);
    WORD* ordinalList   =  (WORD*)((UINT8*)hModule + exports->AddressOfNameOrdinals);

    for (DWORD i = 0; i &lt; exports->NumberOfNames; i++)
    {
        char* curnameptr = (char*)((UINT8*)hModule + nameList[i]);

        if (strcmp(curnameptr, name) == 0)
        {
            WORD ordinal = ordinalList[i];

            function = (void*)((UINT8*)hModule + functionList[ordinal]);

            DWORD fnRVA = functionList[ordinal];

            /// detect if the address lies out side this libraries address range
            /// if so, attempt to cross load it
            if (fnRVA >= exportLocation.VirtualAddress && fnRVA < exportLocation.VirtualAddress + exportLocation.Size)
                return crossLoadFunctionRef(function);

            break;
        }
    }

    return function;

}
                </code></pre>
                <p>The most complicated part is finding the list of exports, after that its a matter of searching. We can't really use a more efficient searching algorithm because the exports are not guaranteed to be in order or even in the same file. This brings us to topic of handling forwarded functions. These are functions that are exported in one DLL, but stored in another. They are in this format: <code>module_name.function_name</code>. </p>
                <p>How do we detect these? We cannot brute force it because that would be slow to run and irritating to write. Instead we can look at the functions <i>Relative Virtual Address</i>. Virtual Addresses are important for virtual memory management. This is an abstraction over memory, so we might have a variable at virtual address <code>0xff23</code>, but it could be at physical address 0x3412. It could even be on the disk if it is paged. RVAs are used in executables to account for this when symbols are being loaded during an executables runtime. </p>
                <p>We can determine whether a function is forwarded by checking its RVA. If it lies outside the bounds defined by the export list, it is forwarded and we can handle it accordingly: </p>
                <pre><code lang="language-cpp">
// C compatible version
static void* LoadForwardedFunction(void* function)
{
    const char* libFunctionPair = (const char*)function;
    
    char libName[256];
    char functionName[256];

    memset(libName, 0, sizeof(libName));
    memset(functionName, 0, sizeof(functionName));

    sscanf(libFunctionPair, "%255[^.].%255s", libName, functionName);

    strcat(libName, ".dll");

    HMODULE fwdLib = LoadModule(libName);

    return GetFunctionAddress(fwdLib, functionName);
}

// C++ version, a little bit slower, but safer
static void* LoadForwardedFunction(void* target)
{
    std::stringstream stream((const char*)target);

    std::string modName;
    std::string fnName;

    if (std::getline(stream, modName, '.') && std::getline(stream, fnName))
    {
        modName += ".dll";

        HMODULE fwdLib = LoadModule(modName.c_str());

        return GetFunctionAddress(fwdLib, fnName.c_str());
    }

    return nullptr;
}


                </code></pre>
                <p>The process would end up looking something like this: </p>
                <pre><code lang="language-cpp">

HMODULE ole32lib = LoadModule("OLE32.DLL");

/// This will require loading forwarded functions
myCoCreateInstance = (MyCoCreateInstance*)GetFunctionAddress(ole32lib, "CoCreateInstance");

                </code></pre>
                
            </section>

            <section id="bonus">
                <h2>Bonus: Function Address Obfuscation</h2>
                <p>While this might not be particularly useful, I thought it would be fun to experiment with. The goal here is to not directly access any function addresses; instead we will shuffle and encrypt the bytes.</p>
                <p>First, we must make a wrapper class whose entire purpose is to provide an automated interface for storage, encryption, and decryption: </p>
                <pre><code lang="language-cpp">
template &lt;class Signature&gt;
class HiddenFunction;

template &lt;class Ret, class... Args&gt;
class HiddenFunction&lt;Ret(Args...)&gt;
{
public:

    using FunctorType = Ret(*)(Args...);

    HiddenFunction() : m_functor(nullptr), m_key(0) {}

    HiddenFunction(FunctorType f) : m_functor(nullptr), m_key(0)
    {
        generateKey(f);
        m_functor = codec(f);
    }

    HiddenFunction(const HiddenFunction& other) 
        : m_functor(other.m_functor) {}

    HiddenFunction(HiddenFunction&& other)
        : m_functor(std::exchange(other.m_functor, nullptr)) {}

    HiddenFunction& operator=(const HiddenFunction& other)
    {
        m_functor = other.m_functor;
        return *this;
    }

    HiddenFunction& operator=(HiddenFunction&& other)
    {
        m_functor = std::exchange(other.m_functor, nullptr);
        return *this;
    }

    Ret operator()(Args&&... args)
    {
        FunctorType decodedPointer = codec(m_functor, true);
        if constexpr (std::is_same_v&lt;Ret, void>)
            decodedPointer(std::forward&lt;Args>(args)...);
        else
            return decodedPointer(std::forward&lt;Args>(args)...);
    }

    private:

    FunctorType codec(FunctorType f, bool decode = false) 
    {
        // to be discussed
    }

    void generateKey(FunctorType f)
    {
        // to be discussed
    }

    FunctorType m_functor;

    uint8_t m_key;
};

                </code></pre>
                <p>The first template declaration tells the compiler the <code>HiddenFunction</code> is a template class. This is necessary because the second declaration is a template specialization. </p>

                <p>Next, we need a way of generating keys. I chose to add all of the bytes that make up the 64 bit address:</p>
                <pre><code class="language-cpp">
void generateKey(FunctorType f)
{
    uint8_t* raw = (uint8_t*)f;
    for (int i = 0; i < 8; i++)
        m_key += raw[i];
}
                </code></pre>
                <p>Next, the address is split into two 32 bit halves, which are swapped. After being joined, they are encrypted: </p>
                <pre><code class="language-cpp">
FunctorType codec(FunctorType f, bool decode = false) 
{
    uint64_t addr = (uint64_t)f;

    uint64_t part1 = (addr & 0xFFFFFFFF) << 32;
    uint64_t part2 = (addr >> 32);
    uint64_t newAddr = 0;
    if (decode)
        newAddr = part2 | part1;
    else
        newAddr = part1 | part2;

    uint8_t* raw = (uint8_t*)&newAddr;

   
    for (int i = 0; i < 8; i++)
        raw[i] ^= m_key;

    return (FunctorType)(newAddr);
}
                </code></pre>
                <p>This is the entire class: </p>
                <details>
                    <summary>HiddenFunction.h</summary>
                    <pre><code lang="language-cpp">
template &lt;class Signature>
class HiddenFunction;


template &lt;class Ret, class... Args>
class HiddenFunction&lt;Ret(Args...)>
{
public:

    using FunctorType = Ret(*)(Args...);

    HiddenFunction() : m_functor(nullptr), m_key(0) {}

    HiddenFunction(FunctorType f) : m_functor(nullptr), m_key(0)
    {
        generateKey(f);
        m_functor = codec(f);
    }

    HiddenFunction(const HiddenFunction& other) 
        : m_functor(other.m_functor) {}

    HiddenFunction(HiddenFunction&& other)
        : m_functor(std::exchange(other.m_functor, nullptr)) {}

    HiddenFunction& operator=(const HiddenFunction& other)
    {
        m_functor = other.m_functor;
        return *this;
    }

    HiddenFunction& operator=(HiddenFunction&& other)
    {
        m_functor = std::exchange(other.m_functor, nullptr);
        return *this;
    }

    Ret operator()(Args&&... args)
    {
        FunctorType decodedPointer = codec(m_functor, true);
        if constexpr (std::is_same_v&lt;Ret, void>)
            decodedPointer(std::forward&lt;Args>(args)...);
        else
            return decodedPointer(std::forward&lt;Args>(args)...);
    }

private:

    FunctorType codec(FunctorType f, bool decode = false) 
    {
        uint64_t addr = (uint64_t)f;

        uint64_t part1 = (addr & 0xFFFFFFFF) << 32;
        uint64_t part2 = (addr >> 32);
        uint64_t newAddr = 0;
        if (decode)
            newAddr = part2 | part1;
        else
            newAddr = part1 | part2;
    
        uint8_t* raw = (uint8_t*)&newAddr;

       
        for (int i = 0; i < 8; i++)
            raw[i] ^= m_key;

        return (FunctorType)(newAddr);
    }
    
    void generateKey(FunctorType f)
    {
        uint8_t* raw = (uint8_t*)f;
        for (int i = 0; i < 8; i++)
            m_key += raw[i];
    }

    FunctorType m_functor;

    uint8_t m_key;
};


                    </code></pre>
                </details>
            </section>
            <p>Here is the end result: </p>
            <img class="article-image img-fluid" src="./media/image.png">
            <br>
            <br>
        </div>
    </div>

    </body>
</html>